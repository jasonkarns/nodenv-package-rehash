#!/usr/bin/env bash
set -e

status=0
program="${0##*/}"
PROGRAM="$(echo "$program" | tr a-z- A-Z_)"
[ -n "$TMPDIR" ] || TMPDIR="/tmp"

_STUB_PLAN="${PROGRAM}_STUB_PLAN"
_STUB_RUN="${PROGRAM}_STUB_RUN"
_STUB_INDEX="${PROGRAM}_STUB_INDEX"
_STUB_RESULT="${PROGRAM}_STUB_RESULT"
_STUB_END="${PROGRAM}_STUB_END"
_STUB_DEBUG="${PROGRAM}_STUB_DEBUG"

if [ -n "${!_STUB_DEBUG}" ]; then
  echo "$program" "$@" >&${!_STUB_DEBUG}
fi

[ -e "${!_STUB_PLAN}" ] || exit 1
[ -n "${!_STUB_RUN}" ] || eval "${_STUB_RUN}"="${TMPDIR}/${program}-stub-run"


# Initialize or load the stub run information.
eval "${_STUB_INDEX}"=1
eval "${_STUB_RESULT}"=0
[ ! -e "${!_STUB_RUN}" ] || source "${!_STUB_RUN}"


# if not stub-end
if [ -z "${!_STUB_END}" ]; then

  # Loop over each line in the plan.
  index=0
  while IFS= read -r line; do
    index=$(($index + 1))

    # Split the line into an array of arguments to
    # match and a command to run to produce output.
    command="$line"
    if [ "$command" != "${command/ : }" ]; then
      expected_args="${command%% : *}"
      command="${command#* : }"
    fi

    arguments="$@"

    # If the arguments match, evaluate the command in a subshell.
    if [ "$arguments" = "$expected_args" ]; then

      set +e
      ( eval "$command" )
      status="$?"
      set -e

    fi

  done < "${!_STUB_PLAN}"

else #unstub

  # Clean up the run file.
  rm -f "${!_STUB_RUN}"

fi
